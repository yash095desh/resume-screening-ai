generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// FEATURE 1: REGULAR JOB POSTINGS
// ==========================================

model User {
  id           String        @id
  email        String        @unique
  name         String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  jobs         Job[]
  sourcingJobs SourcingJob[]

  @@map("users")
}

model Job {
  id                 String          @id @default(uuid())
  userId             String
  title              String
  description        String?
  jdFileUrl          String?
  requiredSkills     String[]
  experienceRequired String?
  qualifications     String[]
  status             String          @default("draft")
  totalCandidates    Int             @default(0)
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  candidates         Candidate[]
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  processingLogs     ProcessingLog[]

  @@index([userId])
  @@map("jobs")
}

model Candidate {
  id                   String   @id @default(uuid())
  jobId                String
  name                 String
  email                String?
  phone                String?
  resumeUrl            String
  resumeText           String?
  skills               String[]
  experience           Json?
  education            Json?
  totalExperienceYears Int?
  matchScore           Int?
  matchedSkills        String[]
  missingSkills        String[]
  fitVerdict           String?
  summary              String?
  strengths            String[]
  weaknesses           String[]
  processingStatus     String   @default("pending")
  processingError      String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  resumePath           String
  job                  Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([matchScore])
  @@map("candidates")
}

model ProcessingLog {
  id               String    @id @default(uuid())
  jobId            String
  status           String
  totalResumes     Int?
  processedResumes Int       @default(0)
  failedResumes    Int       @default(0)
  errorMessage     String?
  startedAt        DateTime  @default(now())
  completedAt      DateTime?
  job              Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@map("processing_logs")
}

// ==========================================
// FEATURE 2: LINKEDIN SOURCING
// ==========================================

enum SourcingJobStatus {
  CREATED
  FORMATTING_JD
  SEARCHING_PROFILES
  SCRAPING_PROFILES
  SCORING
  COMPLETED
  FAILED
}

model SourcingJob {
  id                    String              @id @default(cuid())
  userId                String
  title                 String
  rawJobDescription     String              @db.Text
  maxCandidates         Int                 @default(50)
  
  // === CHECKPOINT SYSTEM ===
  // Stage 1: JD Formatting
  searchFilters         Json?               // LinkedIn search filters from AI
  
  // Stage 2: Profile Discovery
  discoveredUrls        Json?               // Array of profile URLs found
  
  // Stage 3: Batch Processing
  lastCompletedBatch    Int                 @default(0)  // Which batch finished last
  totalBatches          Int                 @default(2)  // Total batches (2Ã—25)
  
  // === PROGRESS TRACKING ===
  status                SourcingJobStatus   @default(CREATED)
  totalProfilesFound    Int                 @default(0)
  profilesScraped       Int                 @default(0)
  profilesScored        Int                 @default(0)
  
  // === CRASH RECOVERY ===
  processingStartedAt   DateTime?
  lastActivityAt        DateTime?           // Updated after each stage/batch
  errorMessage          String?             @db.Text
  retryCount            Int                 @default(0)
  failedAt              DateTime?
  
  // Metadata
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  completedAt           DateTime?
  
  // Relations
  candidates            LinkedInCandidate[]
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, status])
  @@index([lastActivityAt])  // For cron job
  @@index([status, lastActivityAt])  // For finding stuck jobs
}

model LinkedInCandidate {
  id                String        @id @default(cuid())
  sourcingJobId     String
  
  // Profile Info
  fullName          String
  headline          String?
  location          String?
  profileUrl        String
  photoUrl          String?
  
  // Extracted Details
  currentPosition   String?
  currentCompany    String?
  experienceYears   Int?
  skills            Json?
  experience        Json?
  education         Json?
  
  // Contact Info
  email             String?
  phone             String?
  hasContactInfo    Boolean       @default(false)
  
  // === STRUCTURED SCORING RUBRIC ===
  matchScore        Float         @default(0)      // Total (0-100)
  skillsScore       Float         @default(0)      // 0-25
  experienceScore   Float         @default(0)      // 0-25
  industryScore     Float         @default(0)      // 0-25
  titleScore        Float         @default(0)      // 0-25
  matchReason       String?       @db.Text
  isScored          Boolean       @default(false)
  
  // === DEDUPLICATION ===
  isDuplicate       Boolean       @default(false)  // Found in user's other jobs
  firstSeenJobId    String?                        // First job where seen
  
  // Metadata
  batchNumber       Int           @default(0)      // Which batch this came from
  rawData           Json?
  scrapedAt         DateTime      @default(now())
  scoredAt          DateTime?
  
  // Relations
  sourcingJob       SourcingJob   @relation(fields: [sourcingJobId], references: [id], onDelete: Cascade)
  
  @@unique([sourcingJobId, profileUrl])
  @@index([sourcingJobId, matchScore])
  @@index([profileUrl])  // For deduplication check
  @@index([batchNumber])
}
